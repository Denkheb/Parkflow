
-- 1. PROFILES (Matches Demo 'users' table)
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  full_name TEXT,
  email TEXT,
  role TEXT DEFAULT 'user', -- 'admin', 'business', 'user'
  status TEXT DEFAULT 'pending', -- 'pending', 'approved', 'rejected', 'banned'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Ensure 'status' column exists if table was created by an older script
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='profiles' AND column_name='status') THEN
        ALTER TABLE public.profiles ADD COLUMN status TEXT DEFAULT 'pending';
    END IF;
END $$;

-- 2. BUSINESS PROFILES
CREATE TABLE IF NOT EXISTS public.business_profiles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL UNIQUE,
  business_name TEXT NOT NULL,
  license_id TEXT NOT NULL UNIQUE, -- Prevent duplicate applications
  proof_doc_url TEXT,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  total_slots_car INT DEFAULT 10,
  total_slots_bike INT DEFAULT 20,
  price_per_hour DECIMAL(10, 2) DEFAULT 50.00,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. PARKING ASSETS
CREATE TABLE IF NOT EXISTS public.parking_assets (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  owner_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
  name TEXT NOT NULL,
  address TEXT NOT NULL,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  price_per_hour DECIMAL(10, 2) DEFAULT 50.00,
  total_slots_car INT DEFAULT 10,
  total_slots_bike INT DEFAULT 20,
  available_slots_car INT DEFAULT 10,
  available_slots_bike INT DEFAULT 20,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 4. BOOKINGS (Active Sessions / Vehicles)
CREATE TABLE IF NOT EXISTS public.bookings (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  parking_id BIGINT REFERENCES public.parking_assets(id) ON DELETE CASCADE,
  vehicle_number TEXT NOT NULL,
  vehicle_type TEXT NOT NULL,
  owner_name TEXT,
  owner_email TEXT,
  entry_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  exit_time TIMESTAMP WITH TIME ZONE,
  total_amount DECIMAL(10, 2),
  status TEXT DEFAULT 'active', -- 'active', 'completed', 'cancelled'
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 5. TRANSACTIONS
CREATE TABLE IF NOT EXISTS public.transactions (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  booking_id BIGINT REFERENCES public.bookings(id) ON DELETE CASCADE,
  amount DECIMAL(10, 2) NOT NULL,
  payment_method TEXT DEFAULT 'cash',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 6. TRIGGER FUNCTION: Sync User Data
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  -- A. Create Profile (with status)
  INSERT INTO public.profiles (id, full_name, email, role, status)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'full_name', 'No Name'),
    NEW.email,
    COALESCE(NEW.raw_user_meta_data->>'role', 'user'),
    CASE WHEN (NEW.raw_user_meta_data->>'role' = 'admin') THEN 'approved' ELSE 'pending' END
  );

  -- B. If business, create profiles
  IF (NEW.raw_user_meta_data->>'role' = 'business') THEN
    INSERT INTO public.business_profiles (
      user_id, business_name, license_id, proof_doc_url, latitude, longitude
    )
    VALUES (
      NEW.id,
      COALESCE(NEW.raw_user_meta_data->>'business_name', 'My Parking'),
      COALESCE(NEW.raw_user_meta_data->>'license_id', 'N/A'),
      NEW.raw_user_meta_data->>'proof_doc_url',
      (NEW.raw_user_meta_data->>'latitude')::DECIMAL,
      (NEW.raw_user_meta_data->>'longitude')::DECIMAL
    );

    INSERT INTO public.parking_assets (
      owner_id, name, address, latitude, longitude
    )
    VALUES (
      NEW.id,
      COALESCE(NEW.raw_user_meta_data->>'business_name', 'My Parking'),
      COALESCE(NEW.raw_user_meta_data->>'address', 'N/A'),
      (NEW.raw_user_meta_data->>'latitude')::DECIMAL,
      (NEW.raw_user_meta_data->>'longitude')::DECIMAL
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 7. ENABLE TRIGGER
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- 8. SECURITY (RLS) - Dev Friendly
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.business_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.parking_assets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.transactions ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Dev Access" ON public.profiles;
CREATE POLICY "Dev Access" ON public.profiles FOR ALL USING (true);

DROP POLICY IF EXISTS "Dev Access" ON public.business_profiles;
CREATE POLICY "Dev Access" ON public.business_profiles FOR ALL USING (true);

DROP POLICY IF EXISTS "Dev Access" ON public.parking_assets;
CREATE POLICY "Dev Access" ON public.parking_assets FOR ALL USING (true);

DROP POLICY IF EXISTS "Dev Access" ON public.bookings;
CREATE POLICY "Dev Access" ON public.bookings FOR ALL USING (true);

DROP POLICY IF EXISTS "Dev Access" ON public.transactions;
CREATE POLICY "Dev Access" ON public.transactions FOR ALL USING (true);

-- 9. (Optional) Manual Sync / Repair
-- Run this if you have existing users in Auth that aren't showing up
DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='profiles' AND column_name='status') THEN
        ALTER TABLE public.profiles ADD COLUMN status TEXT DEFAULT 'pending';
    END IF;
END $$;

DELETE FROM public.business_profiles a USING public.business_profiles b
WHERE a.id < b.id AND a.user_id = b.user_id;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'business_profiles_user_id_key') THEN
        ALTER TABLE public.business_profiles ADD CONSTRAINT business_profiles_user_id_key UNIQUE (user_id);
    END IF;
END $$;

INSERT INTO public.profiles (id, full_name, email, role, status)
SELECT 
    id, COALESCE(raw_user_meta_data->>'full_name', 'No Name'), email, COALESCE(raw_user_meta_data->>'role', 'user'),
    CASE WHEN (raw_user_meta_data->>'role' = 'admin') THEN 'approved' ELSE 'pending' END
FROM auth.users ON CONFLICT (id) DO UPDATE SET 
    full_name = EXCLUDED.full_name, 
    email = EXCLUDED.email, 
    role = EXCLUDED.role, 
    status = COALESCE(public.profiles.status, EXCLUDED.status);

INSERT INTO public.business_profiles (user_id, business_name, license_id, proof_doc_url, latitude, longitude)
SELECT 
    id, 
    COALESCE(raw_user_meta_data->>'business_name', 'My Parking'), 
    COALESCE(raw_user_meta_data->>'license_id', 'N/A'), 
    raw_user_meta_data->>'proof_doc_url',
    (COALESCE(raw_user_meta_data->>'latitude', '0'))::DECIMAL, 
    (COALESCE(raw_user_meta_data->>'longitude', '0'))::DECIMAL
FROM auth.users WHERE raw_user_meta_data->>'role' = 'business'
ON CONFLICT (user_id) DO UPDATE SET
    business_name = EXCLUDED.business_name, 
    license_id = EXCLUDED.license_id, 
    proof_doc_url = EXCLUDED.proof_doc_url,
    latitude = EXCLUDED.latitude, 
    longitude = EXCLUDED.longitude;

INSERT INTO public.parking_assets (owner_id, name, address, latitude, longitude)
SELECT 
    id, 
    COALESCE(raw_user_meta_data->>'business_name', 'My Parking'), 
    COALESCE(raw_user_meta_data->>'address', 'N/A'),
    (COALESCE(raw_user_meta_data->>'latitude', '0'))::DECIMAL, 
    (COALESCE(raw_user_meta_data->>'longitude', '0'))::DECIMAL
FROM auth.users 
WHERE raw_user_meta_data->>'role' = 'business'
ON CONFLICT DO NOTHING;

-- ========================================================
-- NUCLEAR DATA SYNC & REPAIR (CLEAN SLATE)
-- ========================================================

-- 1. FIX PROFILES TABLE
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS status TEXT DEFAULT 'pending';

-- 2. RECREATE BUSINESS_PROFILES (The Safe Way)
-- This drops and recreates the table to ensure the UNIQUE constraint is there.
DROP TABLE IF EXISTS public.business_profiles CASCADE;

CREATE TABLE public.business_profiles (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL UNIQUE, -- UNIQUE IS KEY
  business_name TEXT NOT NULL,
  license_id TEXT NOT NULL,
  proof_doc_url TEXT,
  latitude DECIMAL(10, 8),
  longitude DECIMAL(11, 8),
  total_slots_car INT DEFAULT 10,
  total_slots_bike INT DEFAULT 20,
  price_per_hour DECIMAL(10, 2) DEFAULT 50.00,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3. RE-SYNC DATA FROM AUTH.USERS
-- Step A: Profiles
INSERT INTO public.profiles (id, full_name, email, role, status)
SELECT 
    id, 
    COALESCE(raw_user_meta_data->>'full_name', 'No Name'), 
    email, 
    COALESCE(raw_user_meta_data->>'role', 'user'),
    CASE WHEN (raw_user_meta_data->>'role' = 'admin') THEN 'approved' ELSE 'pending' END
FROM auth.users
ON CONFLICT (id) DO UPDATE SET 
    full_name = EXCLUDED.full_name,
    email = EXCLUDED.email,
    role = EXCLUDED.role,
    status = EXCLUDED.status;

-- Step B: Business Profiles
INSERT INTO public.business_profiles (user_id, business_name, license_id, latitude, longitude)
SELECT 
    id, 
    COALESCE(raw_user_meta_data->>'business_name', 'My Parking'), 
    COALESCE(raw_user_meta_data->>'license_id', 'N/A'), 
    (COALESCE(raw_user_meta_data->>'latitude', '0'))::DECIMAL, 
    (COALESCE(raw_user_meta_data->>'longitude', '0'))::DECIMAL
FROM auth.users 
WHERE raw_user_meta_data->>'role' = 'business';

-- Step C: Parking Assets
INSERT INTO public.parking_assets (owner_id, name, address, latitude, longitude)
SELECT 
    id, 
    COALESCE(raw_user_meta_data->>'business_name', 'My Parking'), 
    COALESCE(raw_user_meta_data->>'address', 'N/A'),
    (COALESCE(raw_user_meta_data->>'latitude', '0'))::DECIMAL, 
    (COALESCE(raw_user_meta_data->>'longitude', '0'))::DECIMAL
FROM auth.users 
WHERE raw_user_meta_data->>'role' = 'business'
ON CONFLICT DO NOTHING;

-- 4. GRANT PERMISSIONS
GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO postgres, anon, authenticated, service_role;
GRANT ALL ON ALL FUNCTIONS IN SCHEMA public TO postgres, anon, authenticated, service_role;

-- ========================================================
-- STORAGE BUCKET SETUP (Public Access for Proof Documents)
-- ========================================================

-- 1. Create 'documents' bucket if it doesn't exist
-- Note: Supabase Storage requires interacting with 'storage.buckets' table
INSERT INTO storage.buckets (id, name, public)
SELECT 'documents', 'documents', true
WHERE NOT EXISTS (
    SELECT 1 FROM storage.buckets WHERE id = 'documents'
);

-- 2. Add Policies to allow public view (required for Admin Dashboard images)
-- (These will fail if they already exist, so we use a safe block)

DO $$ 
BEGIN
    DROP POLICY IF EXISTS "Public Access" ON storage.objects;
    CREATE POLICY "Public Access" ON storage.objects
      FOR SELECT USING (bucket_id = 'documents');

    DROP POLICY IF EXISTS "Authenticated Upload" ON storage.objects;
    CREATE POLICY "Authenticated Upload" ON storage.objects
      FOR INSERT WITH CHECK (bucket_id = 'documents');
END $$;


ALTER TABLE public.business_profiles ADD COLUMN IF NOT EXISTS max_duration INT DEFAULT 24;
ALTER TABLE public.business_profiles ADD COLUMN IF NOT EXISTS fine_amount DECIMAL(10, 2) DEFAULT 0.00;

ALTER TABLE public.parking_assets ADD COLUMN IF NOT EXISTS is_available BOOLEAN DEFAULT TRUE;
-- 1. Function to synchronize parking_assets based on booking changes
CREATE OR REPLACE FUNCTION sync_parking_slots_on_booking()
RETURNS TRIGGER AS $$
DECLARE
    target_pa_id BIGINT;
BEGIN
    target_pa_id := COALESCE(NEW.parking_id, OLD.parking_id);

    UPDATE public.parking_assets pa
    SET 
        available_slots_car = pa.total_slots_car - (
            SELECT count(*) FROM public.bookings b 
            WHERE b.parking_id = pa.id AND b.vehicle_type = 'car' AND b.status = 'active'
        ),
        available_slots_bike = pa.total_slots_bike - (
            SELECT count(*) FROM public.bookings b 
            WHERE b.parking_id = pa.id AND b.vehicle_type = 'bike' AND b.status = 'active'
        )
    WHERE pa.id = target_pa_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 2. Function to synchronize available slots when TOTAL slots are updated in parking_assets
CREATE OR REPLACE FUNCTION sync_pa_available_on_total_update()
RETURNS TRIGGER AS $$
BEGIN
    -- Recalculate available slots based on NEW total slots and current active bookings
    NEW.available_slots_car := NEW.total_slots_car - (
        SELECT count(*) FROM public.bookings b 
        WHERE b.parking_id = NEW.id AND b.vehicle_type = 'car' AND b.status = 'active'
    );
    NEW.available_slots_bike := NEW.total_slots_bike - (
        SELECT count(*) FROM public.bookings b 
        WHERE b.parking_id = NEW.id AND b.vehicle_type = 'bike' AND b.status = 'active'
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. Enable triggers for Bookings (Handles vehicle entry/exit)
DROP TRIGGER IF EXISTS tr_sync_slots_on_booking ON public.bookings;
CREATE TRIGGER tr_sync_slots_on_booking
AFTER INSERT OR UPDATE OR DELETE ON public.bookings
FOR EACH ROW EXECUTE FUNCTION sync_parking_slots_on_booking();

-- 4. Enable triggers for Parking Assets (Handles settings changes)
DROP TRIGGER IF EXISTS tr_sync_pa_total ON public.parking_assets;
CREATE TRIGGER tr_sync_pa_total
BEFORE UPDATE ON public.parking_assets
FOR EACH ROW 
WHEN (OLD.total_slots_car IS DISTINCT FROM NEW.total_slots_car OR 
      OLD.total_slots_bike IS DISTINCT FROM NEW.total_slots_bike)
EXECUTE FUNCTION sync_pa_available_on_total_update();


UPDATE public.parking_assets pa
SET 
  available_slots_car = pa.total_slots_car - (
    SELECT count(*) FROM public.bookings b 
    WHERE b.parking_id = pa.id AND b.vehicle_type = 'car' AND b.status = 'active'
  ),
  available_slots_bike = pa.total_slots_bike - (
    SELECT count(*) FROM public.bookings b 
    WHERE b.parking_id = pa.id AND b.vehicle_type = 'bike' AND b.status = 'active'
  );
-- ========================================================
-- ABSOLUTE SLOT CALCULATION (Self-Healing)
-- ========================================================

-- 1. Function to recalculate slots for a specific parking lot
CREATE OR REPLACE FUNCTION public.sync_parking_slots(p_id BIGINT)
RETURNS VOID AS $$
DECLARE
    v_active_car INT;
    v_active_bike INT;
    v_total_car INT;
    v_total_bike INT;
BEGIN
    -- Get total slots
    SELECT total_slots_car, total_slots_bike INTO v_total_car, v_total_bike
    FROM public.parking_assets WHERE id = p_id;

    -- Count active bookings
    SELECT COUNT(*) INTO v_active_car FROM public.bookings 
    WHERE parking_id = p_id AND status = 'active' AND vehicle_type = 'car';

    SELECT COUNT(*) INTO v_active_bike FROM public.bookings 
    WHERE parking_id = p_id AND status = 'active' AND vehicle_type = 'bike';

    -- Update available slots (Total - Active)
    UPDATE public.parking_assets 
    SET 
        available_slots_car = GREATEST(0, v_total_car - v_active_car),
        available_slots_bike = GREATEST(0, v_total_bike - v_active_bike)
    WHERE id = p_id;
END;
$$ LANGUAGE plpgsql;

-- 2. Trigger Function to call sync on booking changes
CREATE OR REPLACE FUNCTION public.on_booking_change()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'INSERT') THEN
        PERFORM public.sync_parking_slots(NEW.parking_id);
    ELSIF (TG_OP = 'UPDATE') THEN
        PERFORM public.sync_parking_slots(NEW.parking_id);
        -- If parking_id changed (rare but possible), sync the old one too
        IF (OLD.parking_id <> NEW.parking_id) THEN
            PERFORM public.sync_parking_slots(OLD.parking_id);
        END IF;
    ELSIF (TG_OP = 'DELETE') THEN
        PERFORM public.sync_parking_slots(OLD.parking_id);
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 3. Apply Triggers to 'bookings' table
DROP TRIGGER IF EXISTS tr_refresh_slots ON public.bookings;
CREATE TRIGGER tr_refresh_slots
AFTER INSERT OR UPDATE OR DELETE ON public.bookings
FOR EACH ROW EXECUTE FUNCTION public.on_booking_change();

-- 4. INITIAL SYNC: Run for all existing assets
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN SELECT id FROM public.parking_assets LOOP
        PERFORM public.sync_parking_slots(r.id);
    END LOOP;
END $$;DO $$ 
BEGIN 
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='bookings' AND column_name='owner_name') THEN
        ALTER TABLE public.bookings ADD COLUMN owner_name TEXT;
    END IF;
END $$;

-- ========================================================
-- SYNC BUSINESS STATUS WITH VISIBILITY
-- ========================================================

-- 1. Trigger Function to update parking_assets.is_available based on profile status
CREATE OR REPLACE FUNCTION public.sync_asset_visibility()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        -- If status is changed to something other than 'approved', hide the asset
        IF (NEW.status <> 'approved') THEN
            UPDATE public.parking_assets 
            SET is_available = false 
            WHERE owner_id = NEW.id;
        -- If status is changed to 'approved', make the asset visible
        ELSIF (NEW.status = 'approved') THEN
            UPDATE public.parking_assets 
            SET is_available = true 
            WHERE owner_id = NEW.id;
        END IF;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 2. Apply Trigger to 'profiles' table
DROP TRIGGER IF EXISTS tr_sync_visibility ON public.profiles;
CREATE TRIGGER tr_sync_visibility
AFTER UPDATE OF status ON public.profiles
FOR EACH ROW EXECUTE FUNCTION public.sync_asset_visibility();

-- 3. INITIAL SYNC: Update all existing assets according to current profile status
UPDATE public.parking_assets pa
SET is_available = (p.status = 'approved')
FROM public.profiles p
WHERE pa.owner_id = p.id;



-- ========================================================
-- VERSION 7: STABILITY & DELETE FIX (THE FINAL SOLUTION)
-- ========================================================

-- This script makes your triggers "smart" so they don't crash 
-- when a business or user is being deleted.

-- 1. Fix: sync_parking_slots (Make it NULL-safe)
CREATE OR REPLACE FUNCTION public.sync_parking_slots(p_id BIGINT)
RETURNS VOID AS $$
DECLARE
    v_active_car INT;
    v_active_bike INT;
    v_total_car INT;
    v_total_bike INT;
BEGIN
    -- Check if the parking lot still exists before trying to sync
    SELECT total_slots_car, total_slots_bike INTO v_total_car, v_total_bike
    FROM public.parking_assets WHERE id = p_id;

    -- If the parking lot is gone (deleted), stop here! 
    IF v_total_car IS NULL THEN
        RETURN;
    END IF;

    -- Count active bookings
    SELECT COUNT(*) INTO v_active_car FROM public.bookings 
    WHERE parking_id = p_id AND status = 'active' AND vehicle_type = 'car';

    SELECT COUNT(*) INTO v_active_bike FROM public.bookings 
    WHERE parking_id = p_id AND status = 'active' AND vehicle_type = 'bike';

    -- Update available slots (Total - Active)
    UPDATE public.parking_assets 
    SET 
        available_slots_car = GREATEST(0, v_total_car - v_active_car),
        available_slots_bike = GREATEST(0, v_total_bike - v_active_bike)
    WHERE id = p_id;
END;
$$ LANGUAGE plpgsql;

-- 2. Fix: sync_asset_visibility (Make it safer)
CREATE OR REPLACE FUNCTION public.sync_asset_visibility()
RETURNS TRIGGER AS $$
BEGIN
    -- Only run if the business actually has a parking asset
    IF EXISTS (SELECT 1 FROM public.parking_assets WHERE owner_id = NEW.id) THEN
        IF (NEW.status <> 'approved') THEN
            UPDATE public.parking_assets SET is_available = false WHERE owner_id = NEW.id;
        ELSIF (NEW.status = 'approved') THEN
            UPDATE public.parking_assets SET is_available = true WHERE owner_id = NEW.id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 3. FIX: Ensure all links use CASCADE (Surgically Precise)
DO $$ 
DECLARE 
    r RECORD;
BEGIN
    -- Fix pointers to 'profiles' (excluding the Primary Key)
    FOR r IN (
        SELECT tc.table_schema, tc.table_name, tc.constraint_name, kcu.column_name 
        FROM information_schema.table_constraints AS tc 
        JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name
        JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name
        WHERE tc.constraint_type = 'FOREIGN KEY' 
          AND ccu.table_name = 'profiles' 
          AND ccu.table_schema = 'public'
    ) LOOP
        EXECUTE 'ALTER TABLE ' || quote_ident(r.table_schema) || '.' || quote_ident(r.table_name) || ' DROP CONSTRAINT ' || quote_ident(r.constraint_name);
        EXECUTE 'ALTER TABLE ' || quote_ident(r.table_schema) || '.' || quote_ident(r.table_name) || ' ADD CONSTRAINT ' || quote_ident(r.constraint_name) || 
                ' FOREIGN KEY (' || quote_ident(r.column_name) || ') REFERENCES public.profiles(id) ON DELETE CASCADE';
    END LOOP;

    -- Fix pointers to 'business_profiles'
    FOR r IN (
        SELECT tc.table_schema, tc.table_name, tc.constraint_name, kcu.column_name 
        FROM information_schema.table_constraints AS tc 
        JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name
        JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name
        WHERE tc.constraint_type = 'FOREIGN KEY' AND ccu.table_name = 'business_profiles'
    ) LOOP
        EXECUTE 'ALTER TABLE ' || quote_ident(r.table_schema) || '.' || quote_ident(r.table_name) || ' DROP CONSTRAINT ' || quote_ident(r.constraint_name);
        EXECUTE 'ALTER TABLE ' || quote_ident(r.table_schema) || '.' || quote_ident(r.table_name) || ' ADD CONSTRAINT ' || quote_ident(r.constraint_name) || 
                ' FOREIGN KEY (' || quote_ident(r.column_name) || ') REFERENCES public.business_profiles(id) ON DELETE CASCADE';
    END LOOP;
END $$;

-- 4. Enable Cascade from Auth to Profile
DO $$ 
DECLARE 
    r RECORD;
BEGIN
    FOR r IN (
        SELECT constraint_name FROM information_schema.table_constraints 
        WHERE table_name = 'profiles' AND constraint_type = 'FOREIGN KEY'
    ) LOOP
        EXECUTE 'ALTER TABLE public.profiles DROP CONSTRAINT ' || quote_ident(r.constraint_name);
    END LOOP;
    
    ALTER TABLE public.profiles ADD CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE;
EXCEPTION WHEN OTHERS THEN RAISE NOTICE 'Cascade already set.';
END $$;

-- 5. FINAL Manual Cleanup Trigger (Ordered correctly)
CREATE OR REPLACE FUNCTION public.handle_user_delete_cleanup()
RETURNS TRIGGER AS $$
BEGIN
    -- Delete in dependency order: Bookings -> Assets -> Business -> Profile
    DELETE FROM public.bookings b USING public.parking_assets pa WHERE b.parking_id = pa.id AND pa.owner_id = OLD.id;
    DELETE FROM public.parking_assets WHERE owner_id = OLD.id;
    DELETE FROM public.business_profiles WHERE user_id = OLD.id;
    -- Note: Profiles row is deleted by the system after this trigger
    RETURN OLD;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS tr_user_cleanup ON public.profiles;
CREATE TRIGGER tr_user_cleanup BEFORE DELETE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.handle_user_delete_cleanup();

